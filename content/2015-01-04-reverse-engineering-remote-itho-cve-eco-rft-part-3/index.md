---
title: Reverse engineering remote Itho CVE ECO RFT – Part 3
author: rogier
type: post
date: 2015-01-04T01:41:32+01:00
url: /2015/01/04/reverse-engineering-remote-itho-cve-eco-rft-part-3/
commentFolder: 2015-01-04-reverse-engineering-remote-itho-cve-eco-rft-part-3
categories:
- HomeAutomation
tags:
- arduino
- CC1150
- Itho
resources:
- src: Screenshot-4-all-three-blocks-1024x465.png
  title: Itho RFT All three messages
- src: Screenshot-3-one-block.png
  title: Itho RFT one messages
- src: Screenshot-2-GDO0-simple-parallel.png
  title: Itho RFT first serial part

---
Now that I have saved the data from the logical analyzer, it's time to do the actually analysis. The analyzer software helped me interpret the SPI protocol into hexadecimal values (so I didn't have to count each bit individually). But still there is a lot of communication between the ATMEL microprocessor and the CC1150 chip to changes the speed of the Itho ventilationbox.

[caption id="attachment_84" align="alignnone" width="648"][{{< img "Screenshot-4-all-three-blocks-1024x465.png" ""  "Itho RFT All three messages" >}}](https://www.progz.nl/homeautomation/wp-content/uploads/sites/2/2015/01/Screenshot-4-all-three-blocks.png) Itho RFT All three messages[/caption]

The first thing I noticed was that when you press a button once, 3 identical messages are transmitted using the CC1150. From what I've read this is very common in RF-communication, this way you have a higher change that at least one message will arrive at the other end. The transmission of one message takes about 45 milliseconds then the remote waits 55 miliseconds to send the next message. In total the remote is out of sleep mode for a maximum of 245 milliseconds after 1 button is pressed.

[caption id="attachment_87" align="alignnone" width="956"][{{< img "Screenshot-3-one-block.png" ""  "Itho RFT one messages" >}}](https://www.progz.nl/homeautomation/wp-content/uploads/sites/2/2015/01/Screenshot-3-one-block.png) Itho RFT one messages[/caption]

Each message consist of 5 things:

1) SPI communication to initialize the CC1150
2) serial communication to sent the first part of the message
3) SPI communication to reset and re-initialize the CC1150 for the second time
4) serial communication to sent the second part of the message
5) SPI communication to turn off the CC1150

These 5 steps are repeated identically 3 times for each button you press on the remote. According to the datasheet, the CC1150 would have been able to sent data without using the serial communication mode, it would even perform better if they used this method (since the CC1150 can take care of all the timing aspects). But Itho choose to use the old serial communication method, probably for making the protocol backwards-compatible with older Itho ventilationboxes that do not have a CC1150 yet.

I started reverse engineering the SPI communication first. For this the [CC1150 datasheet](http://www.ti.com/lit/ds/symlink/cc1150.pdf) and the [blogs from @cybergibbons](http://cybergibbons.com/category/alarms-2/friedland-response-reverse-engineering/) where invaluable. To make things a little bit easier for myself, I created an spreadsheet with the captured data on one tab and several lookup tables for Command Strobes and Config Registers from the datasheet on the next. This way I could easily translate the bytes being sent. The first part of the sheets looks like this:
<table style="height: 642px;border-color: #000000" border="1" width="650">
<tbody>
<tr>
<td width="125">Time [s]</td>
<td width="51">Packet ID</td>
<td width="40">MOSI</td>
<td style="width: 48px;vertical-align: middle;text-align: center" width="48">Strobe</td>
<td style="width: 48px;vertical-align: middle;text-align: center" width="58">Register</td>
<td width="242">MOSI meaning</td>
<td width="172">Register/
Command/
Value</td>
<td width="170">Value meaning</td>
</tr>
<tr>
<td>0.000257875</td>
<td>0</td>
<td>0x30</td>
<td style="width: 48px;vertical-align: middle;text-align: center">x</td>
<td style="width: 48px;vertical-align: middle;text-align: center"></td>
<td>Reset chip.</td>
<td>SRES</td>
<td></td>
</tr>
<tr>
<td>0.000425875</td>
<td>1</td>
<td>0x02</td>
<td style="width: 48px;vertical-align: middle;text-align: center"></td>
<td style="width: 48px;vertical-align: middle;text-align: center">x</td>
<td>GDO0 output pin configuration</td>
<td>IOCFG0</td>
<td></td>
</tr>
<tr>
<td>0.000441875</td>
<td>1</td>
<td>0x2E</td>
<td style="width: 48px;vertical-align: middle;text-align: center"></td>
<td style="width: 48px;vertical-align: middle;text-align: center"></td>
<td>0x2E</td>
<td>0x2E</td>
<td>High impedance (3-state).</td>
</tr>
<tr>
<td>0.000516125</td>
<td>2</td>
<td>0x0D</td>
<td style="width: 48px;vertical-align: middle;text-align: center"></td>
<td style="width: 48px;vertical-align: middle;text-align: center">x</td>
<td>Frequency control word, high byte</td>
<td>FREQ2</td>
<td></td>
</tr>
<tr>
<td>0.000532250</td>
<td>2</td>
<td>0x21</td>
<td style="width: 48px;vertical-align: middle;text-align: center"></td>
<td style="width: 48px;vertical-align: middle;text-align: center"></td>
<td>0x21</td>
<td>0x21</td>
<td></td>
</tr>
<tr>
<td>0.000606500</td>
<td>3</td>
<td>0x0E</td>
<td style="width: 48px;vertical-align: middle;text-align: center"></td>
<td style="width: 48px;vertical-align: middle;text-align: center">x</td>
<td>Frequency control word, middle byte</td>
<td>FREQ1</td>
<td></td>
</tr>
<tr>
<td>0.000622500</td>
<td>3</td>
<td>0x65</td>
<td style="width: 48px;vertical-align: middle;text-align: center"></td>
<td style="width: 48px;vertical-align: middle;text-align: center"></td>
<td>0x65</td>
<td>0x65</td>
<td></td>
</tr>
<tr>
<td>0.000696750</td>
<td>4</td>
<td>0x0F</td>
<td style="width: 48px;vertical-align: middle;text-align: center"></td>
<td style="width: 48px;vertical-align: middle;text-align: center">x</td>
<td>Frequency control word, low byte</td>
<td>FREQ0</td>
<td></td>
</tr>
<tr>
<td>0.000712750</td>
<td>4</td>
<td>0x6A</td>
<td style="width: 48px;vertical-align: middle;text-align: center"></td>
<td style="width: 48px;vertical-align: middle;text-align: center"></td>
<td>0x6A</td>
<td>0x6A</td>
<td>868,299865 MHz</td>
</tr>
</tbody>
</table>
 

The first 3 columns (Time, Packet ID and MOSI) came from the logical analyzer. The 2 columns after that (Strobe Register) I've added myself. These 2 columns indicate which lookup table the next two columns (MOSI meaning, Register/Command/Value) should use to lookup the meaning of the MOSI value. The last column I've added manually to translate the values of each register/command to readable text.

Let's look at 3 examples. The first packet ID 0 sents MOSI hexadecimal value 0x30 to the CC1150. In the datasheet on page 42 in table 25 this value translates to Strobe Name "SRES" with the description "Reset chip". This sounds pretty normal; start by resetting the configuration to the default values before configuring anything else (remember the chips comes out of sleep mode after each button press).

The second packet has ID 1. It consists of 2 bytes. The first byte has hexadecimal value 0x02. The second byte has value 0x2E. Looking up up the first byte (0x02) in the datasheet, on page 43 table 26, shows that this is a register address called IOCFG0. The second byte (0x2E) is the value written to it. Looking at page 45 shows that this register consists of one byte and the 8 bits in this byte configure 3 seperate fields:
<table style="height: 170px" border="1" width="650">
<tbody>
<tr>
<td width="64">Bit</td>
<td width="102">Field Name</td>
<td width="64">Reset</td>
<td width="64">R/W</td>
<td width="392">Description</td>
</tr>
<tr>
<td>7</td>
<td>GDO_DS</td>
<td>0</td>
<td>R/W</td>
<td>Set high (1) or low (0) output drive strength on the GDO pins.</td>
</tr>
<tr>
<td>6</td>
<td>GDO1_INV</td>
<td>0</td>
<td>R/W</td>
<td>Invert output, i.e. select active low (1) / high (0).</td>
</tr>
<tr>
<td>5:0</td>
<td>GDO1_CFG[5:0]</td>
<td>46 (0x2E)</td>
<td>R/W</td>
<td>Default is tri-state (See Table 24 on page 38).</td>
</tr>
</tbody>
</table>
 

If we translate hexadecimal value 0x2E to binary (bits), it becomes 00101110. Looking at the table above GDO_DS has bit 7 (the most significant bit, the first bit on the left) which has value 0, so GDO_DS is low. GDO1_INV has bit 6 (the second bit from the left) which is also 0, so GDO1_INV is high. The 6 other bits (101110) are the value for GDO1_CFG. To know what they do, we need to lookup table 24 on page 38 in the datasheet. There it says that 0x2E (the hexidecimal value for binary 101110) is "High impedance (3-state)". In short this means the GDO1 pin outputs data depending on the state the CC1150 is in (either a SPI signal output, or a clock signal, or a temperature value).

**UPDATE: Two very observant people noticed a flaw in my calculation below. So I've striked out and corrected the errors, which have a significant effect on the frequency.**

The next 3 packets sent to the CC1150 configure registers FREQ2, FREQ1 and FREQ0. In the datasheet on page 47 it says we can calculate the value of FREQ using these three register values. All we have to do is paste the values of the 3 registers after each other: 0x21 0x65 <del>0x5A</del> 0x6A. In binary notation this would be 00100001 01100101 <del>01011010</del> 01101010. Using a calculator we can translate this long binary number to a decimal: <del>2188634</del> 2188650.

Now that we have FREQ we can calculate the carrier frequency using the formule on page 34 in the datasheet:
F_CARRIERFREQ = FXOSC / 2 ^ 16 * (FREQ + CHAN * ((256 + CHANSPC_M) * 2 ^ (CHANSPC_E - 2)))

We know that the remote uses an oscillator running at 26MHz from the photo in my earlier blog. So FXOSC is 26000000 (Hz). The values for the other registers used in this formule appear further down the captured data (which I haven't shown in the first table to keep this blog post 'short'). The values are: CHANSPC_M = 248, CHANSPC_E = 2 and CHAN = 0. If we fill these values into the formula we get:

F_CARRIERFREQ =26000000 / 2 ^ 16 * (<del>2188634</del> 2188650+ 0 * ((256 + 248) * 2 ^ (2-2)))
F_CARRIERFREQ =26000000 / 65536 * <del>2188634</del> 2188650
F_CARRIERFREQ = <del>866699064</del> 868299865 Hz
F_CARRIERFREQ = <del>866,699064</del> 868,299865 MHz

Looking at all the data before the first serial transmission, we see the following SPI strobe commands/registers set:


*   SRES - Reset the chip
*   IOCFG0 = GDO0 is configured as input (for serial TX data).
*   IOCFG1 = Serial Clock. Synchronous to the data in synchronous serial mode. In TX mode, data is sampled by CC1150 on the rising edge of the serial clock when GDOx_INV=0.
*   FREQ2, FREQ1, FREQ0 = 868,299865 MHz
*   MDMCFG4, MDMCFG3 = 4004,47845458984375 baud
*   MDMCFG2, MDMCFG1, MDMCFG0


    *   MOD_FORMAT = 2-FSK
    *   MANCHESTER_EN = Disable
    *   SYNC_MODE = No preamble/sync word

*   CHANNR = 0
*   DEVIATN = 25,390625 KHz
*   FREND0


    *   LODIV_BUF_CURRENT_TX = 2
    *   PA_POWER = 7

*   MCSM0


    *   FS_AUTOCAL = Automatically calibrate when going from TX back to IDLE
    *   PO_TIMEOUT = 64

*   FSCAL3, FSCAL2, FSCAL1 = all default values
*   FSTEST, TEST2, TEST1, TEST0 = all values given by SmartRF studio according to the datasheet
*   PKTCTRL0


    *   WHITE_DATA = off
    *   PKT_FORMAT = Serial Synchronous mode, data in on GDO0
    *   CRC_EN = disabled
    *   LENGTH_CONFIG = Infinite packet length packets

*   ADDR = Broadcast
*   PKTLEN = 255
*   SNOP = Burst write PATABLE
*   STX = Enable TX. Perform calibration first if MCSM0.FS_AUTOCAL=1
I have removed the duplicate strobe commands and registers being set. Hopefully when I write my own code I don't have to set the same register multiple times to configure the CC1150 correctly. In the datasheet I didn't find any reference that setting the same register multiple times would be necessary, so the logged data I observed could simply be a programming error made by Itho, or it is necessary for the CC1150 and isn't specified in the datasheet.

The next step is to decode the recorded serial data:

[caption id="attachment_91" align="alignnone" width="956"][{{< img "Screenshot-2-GDO0-simple-parallel.png" ""  "Itho RFT first serial part" >}}](https://www.progz.nl/homeautomation/wp-content/uploads/sites/2/2015/01/Screenshot-2-GDO0-simple-parallel.png) Itho RFT first serial part[/caption]

This is a bit more fuzzy-logic than the SPI data, since it isn't specified in the datasheet for CC1150 and is specific for the Itho ventilationbox. From the registers set with SPI I have gathered that the data will be sent over GDO0 (channel 4 in the picture) and that this data needs to be transmitted on the rising edge of the clock signal provided by the CC1150 on the SO (channel 1 in the picture). Luckily the logical analyzer can be configured to decode the same channel using 2 different protocols (SPI and Simple Parrallel). Exporting this parallel data results in:
<table style="height: 375px" border="1" width="516">
<tbody>
<tr>
<td width="125">Time [s]</td>
<td width="161">binary value</td>
<td width="64">Last bit</td>
<td width="72">Byte value</td>
</tr>
<tr>
<td>0.004950750000000</td>
<td>0b  1111  1111  1111  1111</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>0.005075625000000</td>
<td>0b  1111  1111  1111  1110</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>0.005200500000000</td>
<td>0b  1111  1111  1111  1111</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>0.005325375000000</td>
<td>0b  1111  1111  1111  1110</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>0.005450250000000</td>
<td>0b  1111  1111  1111  1111</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>0.005575125000000</td>
<td>0b  1111  1111  1111  1110</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>0.005700000000000</td>
<td>0b  1111  1111  1111  1111</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>0.005824875000000</td>
<td>0b  1111  1111  1111  1110</td>
<td>0</td>
<td>10101010</td>
</tr>
</tbody>
</table>
Only the last bit of the second column is relevant data (it actually changes), so I've added the third column to show only that bit. I'm assuming the data is being sent using one byte at a time, so after every 8 bits I calculate the binary value of the byte and show this in the fourth column.

The first serial transmission contains exactly 160 bit values, which translates to 20 byte values. For the second serial transmission I'm still a bit uncertain how many byte values are sent. I've recorded multiple traces for the same button press and the number of bits varies between 404 and 408. Most likely my logical analyzer isn't fast enough to record all bits being sent and that is why the total number of recorded bits varies. For the moment I'm going to assume 408 is the correct value, since this means there are 51 bytes being sent. I will have to look at the recorded traces of the other buttons to determine the exact number or else simply try to write some code and see when the ventilationbox actually changes speed. Let's write some code for the Itho ventilationbox and the CC1150 chip next!

**Other posts in this serie: **[Part 1](http://www.progz.nl/blog/index.php/2014/12/reverse-engineering-remote-itho-cve-eco-rft-part-1/ "Reverse engineering remote Itho CVE ECO RFT – Part 1"), [Part 2](http://www.progz.nl/blog/index.php/2014/12/reverse-engineering-remote-itho-cve-eco-rft-part-2/ "Reverse engineering remote Itho CVE ECO RFT – Part 2"), [Part 4](http://www.progz.nl/blog/index.php/2015/02/reverse-engineering-remote-itho-cve-eco-rft-part-4/ "Reverse engineering remote Itho CVE ECO RFT – Part 4"), [part 5](http://www.progz.nl/blog/index.php/2015/02/reverse-engineering-remote-itho-cve-eco-rft-part-5/ "Reverse engineering remote Itho CVE ECO RFT – Part 5"), [Part 6](http://www.progz.nl/blog/index.php/2015/05/reverse-engineering-remote-itho-cve-eco-rft-part-6/)
